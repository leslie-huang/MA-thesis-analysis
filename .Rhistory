sapply(monthly_viol[2:4], function(x) {summary(ur.df(na.omit(x), type = "drift", lags = 1))})
# FARC actions / casualties / demobilization: can't reject null / reject null / reject null: unit root, and no drift
sapply(monthly_viol[2:4], function(x) {summary(ur.df(na.omit(x), type = "none", lags = 1))})
# FARC actions / casualties / demobilization: reject null / can't reject / can't reject
# KPSS
sapply(monthly_viol[2:4], function(x) {kpss.test(x, null = "T")})
# check ndiffs: 1 differencing needed for each trend to make stationary
sapply(monthly_viol[2:4], function(x) { ndiffs(x)})
# Now let's see if FARC actions and army casualties are cointegrated.
viol_VAR <- VAR(na.omit(monthly_viol[,2:3]), p = 2, type = "both")
# test for serial correlation of residuals. Increase lags p = 2 in the VAR model to get p val = 0.94: no autocorrelation
serial.test(viol_VAR)
# Now let's run the Johansen cointgration test
summary(ca.jo(na.omit(monthly_viol[,2:3]), type = "trace", K = 2, ecdet = "trend"))
# result: cointegration
# test Granger causality both ways
# significant only when lags = 3, with p = 0.01
grangertest(na.omit(monthly_viol[,2]) ~ na.omit(monthly_viol[,3]), order = 3)
# significant with p = 0.0007
grangertest(na.omit(monthly_viol[,3]) ~ na.omit(monthly_viol[,2]), order = 1)
# result: army deaths are Granger caused by FARC actions
FARC_breaks_df
govt_breaks_df
joint_breaks_df
FARC_means
FARC_means <- calculate_breakmeans(FARC_breaks_df, FARC_results)
govt_means <- calculate_breakmeans(govt_breaks_df, govt_results)
joint_means <- calculate_breakmeans(joint_breaks_df, joint_results)
#################################################################################
#################################################################################
# Comparison of means: let's look at the means before and after structural breaks
# Function to calculate means in each type of sentiment during "regimes" bounded by structural breaks. Takes two arguments: df of dates with a group ID of break type, and df of loess values. Returns one argument: list of lists of Sentiment Type, Breakdate, and Means
calculate_breakmeans <- function(df, loessed) {
# need to rename groups so they match up with columns in the loess df
df$group <- gsub("neg_break", "EmoNeg", df$group)
df$group <- gsub("pos_break", "EmoPos", df$group)
df$group <- gsub("pp3_break", "Ellos", df$group)
df$group <- gsub("death_break", "Muerte", df$group)
# which types of sentiment have breaks?
groups <- distinct(df, group)$group
# list to contain the means for each sentiment
listofmeans <- vector("list", length(groups))
# for each type of sentiment
for (i in 1:length(groups)) {
# get the breakdates for that type
breaks <- filter(df, group == groups[i])
# get the name of the type
senti_name <- groups[i]
# get the correct columns from the loess df, supplied as an argument to the function
data <- cbind(loessed["date"], loessed[senti_name])
# number of structural breaks
break_len <- length(breaks[[1]])
# IDs to return
IDs <- list(senti_name, breaks["date"])
# Case #1: 2 breaks, 3 regimes
if (break_len == 2) {
data1 <- filter(data, date < breaks[1,1])
mean1 <- mean(unlist(data1[senti_name]))
data2 <- filter(data, date >= breaks[1,1], date < breaks[2,1])
mean2 <- mean(unlist(data2[senti_name]))
data3 <- filter(data, date >= breaks[2,1])
mean3 <- mean(unlist(data3[senti_name]))
means <- c(mean1, mean2, mean3)
}
# Case #2: only 1 break, 2 regimes
else {
data1 <- filter(data, date < breaks[1,1])
mean1 <- mean(unlist(data1[senti_name]))
data2 <- filter(data, date >= breaks[1,1])
mean2 <- mean(unlist(data2[senti_name]))
means <- c(mean1, mean2)
}
listofmeans[[i]] <- list(IDs, means)
}
return(listofmeans)
}
#################################################################################
#################################################################################
# get all the means of regimes defined by structural breakpoints in emotion
FARC_means <- calculate_breakmeans(FARC_breaks_df, FARC_results)
govt_means <- calculate_breakmeans(govt_breaks_df, govt_results)
joint_means <- calculate_breakmeans(joint_breaks_df, joint_results)
FARC_means
govt_means
joint_mans
joint_means
lculate_breakmeans(joint_breaks_df, joint_results)
neg_breaks_gg
pos_breaks_gg
ellos_breaks_gg
death_breaks_gg
# modified version of the breakmeans function
calculate_viol_breakmeans <- function(df, loessed) {
loessed <- na.omit(loessed)
df$group <- gsub("farc_action", "FARC_actions", df$group)
df$group <- gsub("casualties", "deaths_fuerzapublica", df$group)
# which types of sentiment have breaks?
groups <- distinct(df, group)$group
# list to contain the means for each sentiment
listofmeans <- vector("list", length(groups))
# for each type of sentiment
for (i in 1:length(groups)) {
# get the breakdates for that type
breaks <- filter(df, group == groups[i])
# get the name of the type
senti_name <- groups[i]
# get the correct columns from the loess df, supplied as an argument to the function
data <- cbind(loessed["date"], loessed[senti_name])
# IDs to return
IDs <- list(senti_name, breaks["date"])
data1 <- filter(data, date < breaks[1,1])
mean1 <- mean(unlist(data1[senti_name]))
data2 <- filter(data, date >= breaks[1,1], date < breaks[2,1])
mean2 <- mean(unlist(data2[senti_name]))
data3 <- filter(data, date >= breaks[2,1])
mean3 <- mean(unlist(data3[senti_name]))
means <- c(mean1, mean2, mean3)
listofmeans[[i]] <- list(IDs, means)
}
return(listofmeans)
}
viol_means <- calculate_viol_breakmeans(viol_breaks_list, monthly_viol)
viol_breaks_gg
public_op <- read.csv("../MA-datasets/public opinion.csv", stringsAsFactors = FALSE)
public_op <- public_op[,1:3]
public_op$date <- as.Date(as.yearmon(public_op$date, "%Y-%m"))
public_op[,2:3] <- sapply(public_op[,2:3], function(x) { as.numeric(x)})
public_op <- subset(public_op, select = c(2:3, 1))
# graph it
base_opinion = ggplot(public_op, aes(x = as.Date(date, origin = "1970-01-01"), y = santos_positive_image, color = "Positive image of Pres. Santos")) +
geom_smooth(method = "loess", se = FALSE) +
geom_jitter() +
geom_point(data = public_op, aes(x = as.Date(date, origin = "1970-01-01"), y = approve_santos_decision_talks, color = "Approve of negotiations with guerrillas")) +
geom_smooth(method = "loess", se = FALSE, data = public_op, aes(x = as.Date(date, origin = "1970-01-01"), y = approve_santos_decision_talks, color = "Approve of negotiations with guerrillas")) +
labs(
x = "Date",
y = "Percent Approve/Positive Image",
color = "Legend") +
scale_x_date(date_minor_breaks = "1 month",
limits = c(as.Date("2012-01-01", "%Y-%m-%d"), NA)) +
ggtitle("Public Opinion")
# public opinion and ceasefires
opinion_cf = base_opinion +
ggtitle("Public Opinion and Ceasefires") +
geom_rect(aes(xmin=cf_start[1], xmax=cf_end[1], ymin=-Inf, ymax=Inf), fill = "yellow", linetype = 0, alpha = 0.01) +
geom_rect(aes(xmin=cf_start[2], xmax=cf_end[2], ymin=-Inf, ymax=Inf), fill = "yellow", linetype = 0, alpha = 0.01) +
geom_rect(aes(xmin=cf_start[3], xmax=cf_end[3], ymin=-Inf, ymax=Inf), fill = "yellow", linetype = 0, alpha = 0.01) +
geom_rect(aes(xmin=cf_start[4], xmax=cf_end[4], ymin=-Inf, ymax=Inf), fill = "yellow", linetype = 0, alpha = 0.01) +
geom_rect(aes(xmin=cf_start[5], xmax=cf_end[5], ymin=-Inf, ymax=Inf), fill = "yellow", linetype = 0, alpha = 0.01)
# public opinion and major events
opinion_major = base_opinion +
ggtitle("Major Events and Public Opinion Trends") +
geom_vline(data = filter(dates, group == "major_agree"), mapping = aes(xintercept = as.numeric(date), color = "Major agreement"), linetype = 2) +
geom_vline(data = filter(dates, group == "major_viol"), mapping = aes(xintercept = as.numeric(date), color = "Major violence"), linetype = 1)
# get breakdates in public opinion
opinion_breakd <- get_breakdate(break_finder(na.omit(public_op)), public_op)
#################################################################################
#################################################################################
# Markov models
# Hidden Markov model: FARC
# let's limit it to just 3 sentiment measures and starting in 2012
FARC_results1 <- FARC_results[, -4]
FARC_results1 <- filter(FARC_results1, date >= "2012-01-01")
# formulas for the model
forms1 <- list(FARC_results1$EmoNeg ~ 1, FARC_results1$EmoPos ~ 1, FARC_results1$Ellos ~ 1)
#################################################################################
#################################################################################
# What is the optimal number of states? We will optimize for
# (1) BIC, not fitted model
# (2) BIC, fitted model with covariates added
# (3) AIC, fitted model with covariates added
#################################################################################
# Find the optimal number of states based on BIC -- not fitted model
num_states <- seq(2, 10, by = 1)
BIC_vals <- sapply(num_states, function(x) {BIC(depmix(forms1, family = list(gaussian(), gaussian(), gaussian()), nstates = x, data = FARC_results1))})
BIC_df <- data.frame(cbind(num_states, BIC_vals))
# plot the BIC values to select the optimal number of states
BIC_plot <- ggplot(BIC_df, aes(x = num_states, y = BIC_vals)) +
geom_point() +
ggtitle("BIC Values for n = 2:10 Latent States HMM")
#################################################################################
# # Run it again after adding the covariates: monthly violence and public opinion
#
# # Function takes 1 parameter: a dataframe, and returns one parameter with monthly stats for violence and public opinion added: a dataframe
add_monthlies <- function(df) {
dates <- df["date"]
# add columns for the monthly data we're adding
col_names <- c("FARC_actions", "army_casualties", "pres_approve", "peace_approve")
df[, col_names] <- NA
for (i in 1:length(dates[[1]])) {
date <- dates[i, 1]
year <- format(date, "%Y")
month <- format(date, "%m")
monthly_date <- as.Date(paste(year, month, "01", sep = "-"))
# get the stats from violence and opinion dfs
viol <- filter(monthly_viol, date == monthly_date)
public <- filter(public_op, date == monthly_date)
# write them to new df
df["FARC_actions"][i, 1] <- as.numeric(viol[1])
df["army_casualties"][i, 1] <- as.numeric(viol[2])
df["pres_approve"][i, 1] <- as.numeric(public[1])
df["peace_approve"][i, 1] <- as.numeric(public[2])
}
return(df)
}
#################################################################################
# Run function to add violence/public opinion levels to FARC df
# FARC_results2 <- add_monthlies(FARC_results1)
# govt_results1 <- add_monthlies(govt_results)
forms2 <- list(FARC_results2$EmoNeg ~ 1, FARC_results2$EmoPos ~ 1, FARC_results2$Ellos ~ 1)
# Optimize BIC vals for fitted model
BIC_vals2 <- sapply(num_states, function(x) {BIC(fit(depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = x, data = FARC_results2[,-(6:9)])))})
BIC_df2 <- data.frame(cbind(num_states, BIC_vals2))
# plot the BIC values to select the optimal number of states
BIC_plot2 <- ggplot(BIC_df2, aes(x = num_states, y = BIC_vals2)) +
geom_point() +
ggtitle("BIC Values for n = 2:10 Latent States Fitted HMM")
#################################################################################
# what are AIC values of the fitted models?
AIC_vals <- sapply(num_states, function(x) {AIC(fit(depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = x, data = FARC_results2[,-(6:9)])))})
AIC_df <- data.frame(cbind(num_states, AIC_vals))
# plot the AIC values to select the optimal number of states
AIC_plot <- ggplot(AIC_df, aes(x = num_states, y = AIC_vals)) +
geom_point() +
ggtitle("AIC Values for n = 2:10 Latent States Fitted HMM")
#################################################################################
#################################################################################
# HMM wih 3 states
mod <- depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = 3, data = FARC_results2[,-(6:9)])
hmm_mod <- fit(mod)
summary(hmm_mod)
# what state are we in at a given time t?
head(posterior(hmm_mod))
# graph this later
# Function takes 1 parameter: a dataframe, and returns one parameter with monthly stats for violence and public opinion added: a dataframe
add_monthlies <- function(df) {
dates <- df["date"]
# add columns for the monthly data we're adding
col_names <- c("FARC_actions", "army_casualties", "pres_approve", "peace_approve")
df[, col_names] <- NA
for (i in 1:length(dates[[1]])) {
date <- dates[i, 1]
year <- format(date, "%Y")
month <- format(date, "%m")
monthly_date <- as.Date(paste(year, month, "01", sep = "-"))
# get the stats from violence and opinion dfs
viol <- filter(monthly_viol, date == monthly_date)
public <- filter(public_op, date == monthly_date)
# write them to new df
df["FARC_actions"][i, 1] <- as.numeric(viol[1])
df["army_casualties"][i, 1] <- as.numeric(viol[2])
df["pres_approve"][i, 1] <- as.numeric(public[1])
df["peace_approve"][i, 1] <- as.numeric(public[2])
}
return(df)
}
FARC_results2 <- add_monthlies(FARC_results1)
govt_results1 <- add_monthlies(govt_results)
forms2 <- list(FARC_results2$EmoNeg ~ 1, FARC_results2$EmoPos ~ 1, FARC_results2$Ellos ~ 1)
# Optimize BIC vals for fitted model
BIC_vals2 <- sapply(num_states, function(x) {BIC(fit(depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = x, data = FARC_results2[,-(6:9)])))})
BIC_df2 <- data.frame(cbind(num_states, BIC_vals2))
# plot the BIC values to select the optimal number of states
BIC_plot2 <- ggplot(BIC_df2, aes(x = num_states, y = BIC_vals2)) +
geom_point() +
ggtitle("BIC Values for n = 2:10 Latent States Fitted HMM")
#################################################################################
# what are AIC values of the fitted models?
AIC_vals <- sapply(num_states, function(x) {AIC(fit(depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = x, data = FARC_results2[,-(6:9)])))})
AIC_df <- data.frame(cbind(num_states, AIC_vals))
# plot the AIC values to select the optimal number of states
AIC_plot <- ggplot(AIC_df, aes(x = num_states, y = AIC_vals)) +
geom_point() +
ggtitle("AIC Values for n = 2:10 Latent States Fitted HMM")
#################################################################################
#################################################################################
# HMM wih 3 states
mod <- depmix(forms2, family = list(gaussian(), gaussian(), gaussian()), nstates = 3, data = FARC_results2[,-(6:9)])
hmm_mod <- fit(mod)
summary(hmm_mod)
# what state are we in at a given time t?
head(posterior(hmm_mod))
# graph this later
#################################################################################
#################################################################################
# PCA analysis
FARC_corpus <- corpus(FARC$text, docvars = FARC_results$dates)
govt_corpus <- corpus(govt$text, docvars = govt_results$dates)
all_corpora <- FARC_corpus + govt_corpus
# docvars for inserting: sides and dates
sides <- c(rep("FARC", length(FARC_corpus[, 1])), rep("govt", length(govt_corpus[, 1])))
pca_dates <- c(FARC_results$date, govt_results$date)
# make dfm
all_dfm <- dfm(all_corpora, language = "spanish", stem = TRUE, ignoredFeatures = stopwords("spanish"))
# run PCA
statements_PCA <- prcomp(all_dfm, center = TRUE, scale. = TRUE)
summary(statements_PCA)
# what are the loadings?
head(statements_PCA$rotation)
# plot it
plot(statements_PCA, type = "l", main="PCA of FARC and Govt Statements")
# first 2 PCs account for ~10% of variance. Could be better...
# create graph of PC1 and PC2
PC_graph <- ggbiplot(statements_PCA, obs.scale = 1, var.scale = 1, groups = sides)
PC_graph <- PC_graph + theme(legend.direction = "horizontal", legend.position = "top")
PC_graph
# Graph PC1 as a time series:
# collect date and side metadata with PC1 values
statements_PC1_2 <- data.frame(statements_PCA$x[1:length(statements_PCA$x[,1]),1:2])
statements_PC1_2["date"] <- pca_dates
statements_PC1_2["side"] <- sides
colnames(statements_PC1_2) <- c("PC1", "PC2", "date", "side")
PC1_gg <- ggplot(filter(statements_PC1_2, side == "FARC"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "FARC")) +
geom_jitter() +
geom_point(data = filter(statements_PC1_2, side == "govt"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "Govt")) +
ggtitle("Plot of First Principal Components over Time") +
scale_x_date(date_minor_breaks = "1 month",
limits = c(as.Date("2012-06-01", "%Y-%m-%d"), NA))
# Graph PC2
# collect date and side metadata with PC1 values
PC2_gg <- ggplot(filter(statements_PC1_2, side == "FARC"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC2, color = "FARC")) +
geom_jitter() +
geom_point(data = filter(statements_PC1_2, side == "govt"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC2, color = "Govt")) +
ggtitle("Plot of Second Principal Components over Time") +
scale_x_date(date_minor_breaks = "1 month",
limits = c(as.Date("2012-06-01", "%Y-%m-%d"), NA))
#################################################################################
#################################################################################
# FARC statement # 94 is an outlier. Let's try removing it, adding log transformation, and rerun PCA
# trimmed_statements_PC1_2 <- filter(statements_PC1_2, PC2 < 231)
FARC_corpus_trimmed <- corpus(FARC$text[-94], docvars = FARC_results$dates[-94])
all_corpora_trimmed <- FARC_corpus_trimmed + govt_corpus
all_dfm_trimmed <- dfm(all_corpora_trimmed, language = "spanish", stem = TRUE, ignoredFeatures = stopwords("spanish"))
statements_PCA_trimmed <- prcomp(all_dfm_trimmed, center = TRUE, scale. = TRUE)
summary(statements_PCA_trimmed)
# plot it: still not great
plot(statements_PCA_trimmed, type = "l", main="PCA of FARC and Govt Statements")
statements_PC1_2_trimmed <- data.frame(statements_PCA_trimmed$x[1:length(statements_PCA_trimmed$x[,1]),1:2])
statements_PC1_2_trimmed["date"] <- pca_dates[-94]
statements_PC1_2_trimmed["side"] <- sides[-94]
colnames(statements_PC1_2_trimmed) <- c("PC1", "PC2", "date", "side")
# Plot PC1 time series
PC1_gg_trimmed <- ggplot(filter(statements_PC1_2_trimmed, side == "FARC"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "FARC")) +
geom_smooth(method = "loess", se = FALSE) +
geom_jitter() +
geom_point(data = filter(statements_PC1_2_trimmed, side == "govt"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "Govt")) +
geom_smooth(method = "loess", se = FALSE, data = statements_PC1_2_trimmed, aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "Govt")) +
ggtitle("Plot of First Principal Components over Time (Outlier Removed)") +
scale_x_date(date_minor_breaks = "1 month",
limits = c(as.Date("2012-06-01", "%Y-%m-%d"), NA)) +
labs(
x = "Date",
y = "PC1",
color = "Legend")
# Graph PC2
# collect date and side metadata with PC1 values
PC2_gg_trimmed <- ggplot(filter(statements_PC1_2_trimmed, side == "FARC"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC2, color = "FARC")) +
geom_smooth(method = "loess", se = FALSE) +
geom_jitter() +
geom_point(data = filter(statements_PC1_2_trimmed, side == "govt"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC2, color = "Govt")) +
geom_smooth(method = "loess", se = FALSE, data = statements_PC1_2_trimmed, aes(x = as.Date(date, origin = "1970-01-01"), y = PC2, color = "Govt")) +
ggtitle("Plot of Second Principal Components over Time (Outlier Removed)") +
scale_x_date(date_minor_breaks = "1 month",
limits = c(as.Date("2012-06-01", "%Y-%m-%d"), NA)) +
labs(
x = "Date",
y = "PC2",
color = "Legend")
# what words are correlated with PC1 or PC2?
PC_df <- fortify(statements_PCA$rotation)
words <- row.names(PC_df)
PC_df <- cbind(words, PC_df)
# top words associated with PC1
PC_df1 <- arrange(PC_df, PC1)
View(PC_df1)
# top words associated with PC2
PC_df2 <- arrange(PC_df, PC2)
View(PC_df2)
#################################################################################
#################################################################################
# # Robust PCA
# rob_pca <- PcaHubert(all_dfm)
# # First 2 components account for 65% of variance
# print(rob_pca)
# summary(rob_pca)
#
# # plot
# screeplot(rob_pca, type = "lines", main = "Robust PCA with 10 Components")
#
# # let's plot the time series of PC1
# rob_pc1 <- data.frame(rob_pca@scores)
# rob_pc1 <- dplyr::select(rob_pc1, PC1)
# rob_pc1["side"] <- sides
# rob_pc1["date"] <- pca_dates
#
# # Robust PC1 graph
# PC1_gg_robust <- ggplot(filter(rob_pc1, side == "FARC"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "FARC")) +
#   geom_smooth(method = "loess", se = FALSE) +
#   geom_jitter() +
#   geom_point(data = filter(rob_pc1, side == "govt"), aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "Govt")) +
#   geom_smooth(method = "loess", se = FALSE, data = rob_pc1, aes(x = as.Date(date, origin = "1970-01-01"), y = PC1, color = "Govt")) +
#   ggtitle("Plot of First Principal Components over Time (Robust PCA)") +
#   scale_x_date(date_minor_breaks = "1 month",
#                limits = c(as.Date("2012-06-01", "%Y-%m-%d"), NA)) +
#   labs(
#     x = "Date",
#     y = "PC1",
#     color = "Legend")
#################################################################################
#################################################################################
# Transition model: sentiment-responds-to-sentiment
# Classify overall sentiment as "high" or "low": Compare negative and positive emotion proportions within a given document. 1 = high, 0 = low
FARC_results3 <- FARC_results
FARC_results3["sentiment_level"] <- as.numeric(2 * FARC_results3$EmoNeg <= FARC_results3$EmoPos)
FARC_results3["side"] <- "FARC"
govt_results3 <- govt_results
govt_results3["side"] <- "govt"
govt_results3["sentiment_level"] <- as.numeric(2 * govt_results3$EmoNeg <= govt_results3$EmoPos)
# combine them into one stream
transition_chain <- rbind(FARC_results3, govt_results3)
# and sort by date
transition_chain <- transition_chain[order(as.Date(transition_chain$date, format = "%Y-%m-%d")), ]
# and filter to the peace process
transition_chain <- filter(transition_chain, date > "2012-01-01")
# pairwise comparison to gauge "responsiveness": how often are the parties giving statements at t and t-1 different?
get_responsiveness <- function(df) {
# put boolean of pairwise comparisons here
vect <- rep(NA, (length(df[ , 1]) - 1))
for (i in 2:length(df[ , 1])) {
side_t <- df["side"][i, ]
side_t_1 <- df["side"][i-1, ]
vect[i] <- side_t != side_t_1
}
return(vect)
}
# how frequent are "responding pairs"?
pairwise_responsiveness <- get_responsiveness(transition_chain)
pairwise_num <- sum(na.omit(as.numeric(pairwise_responsiveness)))
pairwise_num
#################################################################################
#################################################################################
# Multinomial logit fitted MLE
# Let's get our dataset!!!!!!
mnl_df <- dplyr::select(transition_chain, date, sentiment_level, side)
# state_x = current state at t, state_y = next state at t+1
# State1 = FARC-low, State 2 = FARC-high, State 3 = govt-low, State 4 = govt-high
# Function takes 1 parameter: a df with "side" and "sentiment_level" variables
state_maker <- function(df) {
df["state_x"] <- NA
# fill in the appropriate states
for (i in 1:length(df[, 1])) {
# Divide FARC into states 1 and 2
if (df["side"][i, ] == "FARC") {
if (df["sentiment_level"][i, ] == 0) {
df["state_x"][i, ] <- 1
}
else {
df["state_x"][i, ] <- 2
}
}
# Divide govt into states 3 and 4
if (df["side"][i, ] == "govt") {
if (df["sentiment_level"][i, ] == 0) {
df["state_x"][i, ] <- 3
}
else {
df["state_x"][i, ] <- 4
}
}
}
df["state_y"] <- NA
for (i in 1:length(df[, 1]) -1) {
df["state_y"][i, ] <- df["state_x"][i+1, ]
}
return(df)
}
mnl_df <- state_maker(mnl_df)
# add the violence and public opinion stats to the dataset (for fixed effects) and then take their logs
mnl_df <- add_monthlies(mnl_df)
mnl_df[6:9] <- log(mnl_df[6:9])
# add year for random/fixed effects
mnl_df$year <- mnl_df$date
mnl_df$year <- sapply(mnl_df$year, function(x) {substr(toString(x), 1, 4)})
mnl_df$state_y <- factor(mnl_df$state_y)
# factor and relevel
mnl_df$state_y2 <- relevel(mnl_df$state_y, ref = "1")
# Run the model
mnl_mod <- multinom(state_y2 ~ state_x + year, data = mnl_df, na.action = na.omit)
summary(mnl_mod)
View(FARC_results)
write.dta(mnl_df, "mnl_data.dta")
mnl_df <- add_monthlies(mnl_df)
mnl_df[6:9] <- mnl_df[6:9] +1
View(mnl_df)
mnl_df <- add_monthlies(mnl_df)
mnl_df[6:9] <- log(mnl_df[6:9] + 1)
mnl_df$year <- mnl_df$date
mnl_df$year <- sapply(mnl_df$year, function(x) {substr(toString(x), 1, 4)})
mnl_df$state_y <- factor(mnl_df$state_y)
# factor and relevel
mnl_df$state_y2 <- relevel(mnl_df$state_y, ref = "1")
# Run the model
mnl_mod <- multinom(state_y2 ~ state_x + year, data = mnl_df, na.action = na.omit)
summary(mnl_mod)
# Export to Stata.... sigh
write.dta(mnl_df, "mnl_data.dta")
mnl_mod <- multinom(state_y2 ~ state_x + FARC_actions + pres_approve + year, data = mnl_df, na.action = na.omit)
summary(mnl_mod)
mnl_mod <- multinom(state_y2 ~ state_x + FARC_actions + pres_approve, data = mnl_df, na.action = na.omit)
summary(mnl_mod)
mnl_mod <- multinom(state_y2 ~ state_x, data = mnl_df, na.action = na.omit)
summary(mnl_mod)
